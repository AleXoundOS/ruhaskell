<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content>
        <meta name="author" content>
        <link rel="icon" href="../../../../../static/images/favicon.ico">

        <title>Десериализация с зависимыми типами (простая версия)</title>

        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">

        <link href="../../../../../static/css/default.css" rel="stylesheet">

        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>

        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://ruhaskell.org/feed.xml" />

        <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
    </head>

  <body>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-58217738-1', 'auto');
      ga('send', 'pageview');

    </script>

    <div class="container">
        <nav class="navbar navbar-default navbar-fixed-top">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <div id="ruhaskell-logo">
                <a class="navbar-brand" href="../../../../../" title="Домой">
                  <img alt="ruHaskell" src="../../../../../static/images/logo.png" width="60">
                </a>
              </div>
            </div>

            <div id="navbar" class="collapse navbar-collapse">
              <ul class="nav navbar-nav">
                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Публикации<span class="caret"></span>
                  </a>
                  <ul class="dropdown-menu" role="menu">
                    <li>
                        <a href="../../../../../archive.html">
                            <span class="archive-link">
                                <span class="fa fa-pencil"></span>
                            </span>Статьи
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../tags.html">
                            <span class="tags-link">
                                <span class="fa fa-tags"></span>
                            </span>Теги
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../categories.html">
                            <span class="categories-link">
                                <span class="fa fa-star"></span>
                            </span>Категории
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../authors.html">
                            <span class="authors-link">
                                <span class="fa fa-users"></span>
                            </span>Авторы
                        </a>
                    </li>
                  </ul>
                </li>

                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Общение<span class="caret"></span>
                  </a>
                  <ul class="dropdown-menu" role="menu">
                    <li>
                        <a href="https://gitter.im/ruHaskell/forall" target="_blank">
                            <span class="chat-link">
                                <span class="fa fa-smile-o"></span>
                            </span>Чат
                        </a>
                    </li>
                    <li>
                        <a href="https://www.reddit.com/r/ruhaskell/" target="_blank">
                            <span class="group-link">
                                <span class="fa fa-reddit-alien"></span>
                            </span>reddit
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../maillist.html">
                            <span class="group-link">
                                <span class="fa fa-group"></span>
                            </span>Список рассылки
                        </a>
                    </li>
                  </ul>
                </li>

                <li><a href="../../../../../links.html">Ссылки</a></li>
              </ul>

              <ul class="nav navbar-nav navbar-right">
                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Присоединяйтесь!<span class="caret"></span>
                  </a>
                  <ul class="dropdown-menu" role="menu">
                    <li>
                        <a href="https://twitter.com/RuHaskell" target="_blank">
                            <span id="twitter-link">
                                <span class="fa fa-twitter-square"></span>
                            </span>Twitter
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/ruHaskell/ruhaskell" target="_blank">
                            <span id="github-link">
                                <span class="fa fa-github-square"></span>
                            </span>GitHub
                        </a>
                    </li>
                    <li>
                        <a href="https://plus.google.com/communities/117343381540538069054" target="_blank">
                            <span id="google-plus-link">
                                <span class="fa fa-google-plus-square"></span>
                            </span>Google+
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../feed.xml">
                            <span id="rss-link">
                                <span class="fa fa-rss-square"></span>
                            </span>RSS
                        </a>
                    </li>
                    <li>
                        <a href="http://bananasandlenses.net/" target="_blank">
                            <span id="bananasandlenses-link">
                                <span class="fa fa-headphones"></span>
                            </span>Подкаст
                        </a>
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </nav>

        <div id="content">
            <h1>Десериализация с зависимыми типами (простая версия)</h1>

<div class="row">
    <div class="col-xs-9 col-sm-8 col-md-8 col-lg-8">
        <div class="post-info">
            <strong>let</strong> author&nbsp;&nbsp;&nbsp;= "<a href="../../../../../authors/%D0%90%D0%BB%D0%B5%D0%BA%D1%81%D0%B0%D0%BD%D0%B4%D1%80%20%D0%92%D0%B5%D1%80%D1%88%D0%B8%D0%BB%D0%BE%D0%B2.html">Александр Вершилов</a>"<br />
            &nbsp;&nbsp;&nbsp;&nbsp;date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= fromGregorian 2016 jan 06<br />
            &nbsp;&nbsp;&nbsp;&nbsp;category = "<a href="../../../../../categories/theory.html">Теория</a>"<br />
            &nbsp;&nbsp;&nbsp;&nbsp;tags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [&quot;<a href="../../../../../tags/%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B.html">зависимые типы</a>&quot;, &quot;<a href="../../../../../tags/%D1%81%D0%B5%D0%BC%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B0%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2.html">семейства типов</a>&quot;, &quot;<a href="../../../../../tags/%D1%81%D0%BE%D1%80%D1%82%D0%B0.html">сорта</a>&quot;, &quot;<a href="../../../../../tags/%D1%81%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F.html">сериализация</a>&quot;]
        </div>
    </div>

    <div class="col-xs-3 col-sm-4 col-md-4 col-lg-4">
        
    </div>
</div>

<p>Задача появилась в сети <a href="http://juick.com/2816427">juick</a> у <span class="citation">[@ndtimofeev]</span>(https://github.com/ndtimofeev). Соответственно основная часть кода, не относящегося к сериализации, принадлежит ему. Переформулированная задача: есть формат данных из сети, а именно <a href="https://otr.cypherpunks.ca/">Otr</a> сообщение, в котором передается заголовок, описывающий тип данных (payload), передаваемый далее. Варианты типов являются закрытым множеством.</p>
<div class="figure">
<img src="../../../../../files/posts/2016-01-06/message.png" />

</div>
<p>Хотелось бы создать для таких сообщений удобное внутреннее представление, которое будет предоставлять гарантии безопасности, удобный API и невысокие дополнительные расходы, и позволяющее сериализовать и десериализовать сообщения.</p>
<p>Для начала рассмотрим самое простое решение, работающее во многих случаях</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AnyPayload</span> <span class="fu">=</span> <span class="dt">DiffieHellmanCommit</span> <span class="fu">...</span>
                <span class="fu">|</span> <span class="dt">DiffieHellmanKey</span> <span class="fu">...</span>
                <span class="fu">|</span> <span class="dt">DataMessage</span> <span class="fu">...</span>

<span class="kw">data</span> <span class="dt">AnyOtrMessage</span> <span class="fu">=</span> <span class="dt">AnyOtrMessage</span> <span class="dt">Word16</span> <span class="dt">Word32</span> <span class="dt">Word32</span> <span class="dt">AnyPayload</span></code></pre></div>
<p>Здесь мы определяем простой алгебраический тип данных, описывающий варианты payload. Для такого представления достаточно просто написать необходимые инстансы <code>Binary</code>. Также такой тип не требует особых знаний языка при его написании и поддержке кода. Однако тут возникают некоторые проблемы:</p>
<ol style="list-style-type: decimal">
<li>Даже если мы знаем тип приходящего сообщения (определяется протоколом), то нам все равно нужно читать <code>AnyOtrMessage</code> и рассматривать все кейсы <code>AnyPayload</code>. Эту проблему можно облегчить, если использовать линзы, но полностью она решена не будет.</li>
<li>Из-за дополнительной косвенности вызовов накладываются дополнительные расходы.</li>
</ol>
<p>Попробуем найти другое решение, которое позволит решить данные вопросы. В целом нам бы хотелось получить некоторое представление <code>OtrMessage</code>, параметризованное типом payload, и <code>SomeOtrMessage</code> для случая, когда тип сообщения не известен.</p>
<p>Замечу, что в посте есть небольшое количество диаграмм, данные диаграммы не относятся к ТК, как бы ни хотелось автору, однако общие идеи взяты из идей отображения категорий. Если у кого-либо из читателей возникнет желание поправить диаграммы так, чтобы они были более точными, то это всячески приветствуется.</p>
<p>Сначала введем тип данных, описывающий варианты <code>payload</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MessageType</span> <span class="fu">=</span> <span class="dt">DiffieHellmanCommit</span>
                 <span class="fu">|</span> <span class="dt">DiffieHellmanKey</span>
                 <span class="fu">|</span> <span class="dt">RevealSignature</span>
                 <span class="fu">|</span> <span class="dt">Signature</span>
                 <span class="fu">|</span> <span class="dt">DataMessage</span>
                 <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p>Для данного типа просто написать <code>Binary</code> инстанс. Единственное, что в нём можно было бы улучшить, это описать константы более декларативно, но этого мы коснёмся далее.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> <span class="dt">MessageType</span> <span class="kw">where</span>
  get <span class="fu">=</span> flip fmap getWord8 <span class="fu">$</span> \<span class="kw">case</span>
    <span class="bn">0x03</span> <span class="ot">-&gt;</span> <span class="dt">DataMessage</span>
    <span class="bn">0x02</span> <span class="ot">-&gt;</span> <span class="dt">DiffieHellmanCommit</span>
    <span class="bn">0x0a</span> <span class="ot">-&gt;</span> <span class="dt">DiffieHellmanKey</span>
    <span class="bn">0x11</span> <span class="ot">-&gt;</span> <span class="dt">RevealSignature</span>
    <span class="bn">0x12</span> <span class="ot">-&gt;</span> <span class="dt">Signature</span>
    _    <span class="ot">-&gt;</span> fail <span class="st">&quot;Unknown Tag&quot;</span>
  put <span class="dt">DataMessage</span>         <span class="fu">=</span> putWord8 <span class="bn">0x03</span>
  put <span class="dt">DiffieHellmanCommit</span> <span class="fu">=</span> putWord8 <span class="bn">0x02</span>
  put <span class="dt">DiffieHellmanKey</span>    <span class="fu">=</span> putWord8 <span class="bn">0x0a</span>
  put <span class="dt">RevealSignature</span>     <span class="fu">=</span> putWord8 <span class="bn">0x11</span>
  put <span class="dt">Signature</span>           <span class="fu">=</span> putWord8 <span class="bn">0x12</span></code></pre></div>
<p>Теперь хотелось бы сделать так, чтобы значение типа <code>MessageType</code> определяло бы payload в <code>OtrMessage</code>, в котором он хранится. Сложность тут заключается в том, что значение хранится “на уровне значений”, т.е. во время исполнения, а тип payload на уровне типов, т.е. во время компиляции. Если тип <code>payload</code> будет определен, то мы сможем получить соответствующий этому типу сериализатор.</p>
<div class="figure">
<img src="../../../../../files/posts/2016-01-06/step-1.png" />

</div>
<p>Для того, чтобы построить такую связь, нам надо поднять информацию о конструкторах <code>MessageType</code> на уровень типов. Это возможно благодаря расширению <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html">DataKinds</a>. Данное расширение позволяет определять новые сорта (kinds), соответствующие типу данных и населенные конструкторами данного типа. Т.е. на уровне типов мы можем создать параметризованный другим типом сорта <code>MessageType</code>, который может принимать значения (на уровне типов <code>'DiffieHellmanCommit</code>, <code>'DiffieHellmanKey</code>,…).</p>
<p>Таким образом мы получаем диаграмму</p>
<div class="figure">
<img src="../../../../../files/posts/2016-01-06/step-2.png" />

</div>
<p>Имея информацию о конструкторах <code>MessageType</code> на уровне типов, мы можем построить отображения этой информации в типы данных, которые хранятся в сообщении. Т.к. это операция на уровне типов, то мы её можем записать при помощи одного из следующих методов:</p>
<ol style="list-style-type: decimal">
<li>Классы типов с функциональными зависимостями</li>
<li>Открытые семейства типов</li>
<li>Закрытые семейства типов</li>
<li>Семейства данных</li>
</ol>
<p>Классы типов и открытые семейства типов полезны в случае, если у нас есть открытое множество типов сообщений (это не наш случай). Также семейства типов и классы типов могут использоваться в том случае, если нам необходимо создать связь с уже написанными в другом месте типами (не наш случай). Также семейства типов, даже закрытые, не являются инъективными, т.е. имея выражение <span class="math inline">\(F(X)=Y\)</span> и зная <span class="math inline">\(Y\)</span>, мы не можем восстановить тип <span class="math inline">\(X\)</span>. Семейства данных решают нашу проблему и не вносят доп. ограничений. В принципе ту же задачу можно решить и при помощи классов типов с функциональными зависимостями, но код в этом случае будет немного сложнее для написания, и при этом случаев, где (CTFD) имеют дополнительные полезные свойства, в задаче не возникает.</p>
<p>Инъективность полезна, если наш тип будет использоваться только в ковариантной позиции, в этом случае, если преобразование не инъективно, значение типа не является достаточной информацией для вывода всех типов. А в данной задаче это важно при написании хотя бы инстансов <code>Binary</code>.</p>
<p>Т.е. для решения задачи мы можем определить семейство данных, которое создает однозначное соответствие между конструктором <code>MessageType</code> на уровне типов и типом данных (и его конструкторами).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> family <span class="dt">OtrMessagePayload</span> (<span class="ot">a::</span><span class="dt">MessageType</span>)<span class="ot"> ::</span> <span class="fu">*</span></code></pre></div>
<p>И реализуем несколько сообщений</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">OtrMessagePayload</span> <span class="ch">'DiffieHellmanCommit = MkDiffieHellmanCommit { encryptedGX :: !ByteString, hashedGX :: !ByteString}</span>
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)
<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">OtrMessagePayload</span> <span class="ch">'DiffieHellmanKey = MkDiffieHellmanKey { gY :: MPI }</span>
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="co">-- Binary instances</span>
<span class="kw">instance</span> <span class="dt">Binary</span> (<span class="dt">OtrMessagePayload</span> <span class="ch">'DiffieHellmanCommit)</span>
<span class="kw">instance</span> <span class="dt">Binary</span> (<span class="dt">OtrMessagePayload</span> <span class="ch">'DiffieHellmanKey)</span></code></pre></div>
<p>Для того, чтобы не писать громоздкие имена, можно ввести немного синонимов типов:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DiffieHellmanCommit</span> <span class="fu">=</span> <span class="dt">OtrMessagePayload</span> <span class="ch">'DiffieHellmanCommit</span>
<span class="kw">type</span> <span class="dt">DiffieHellmanKey</span>    <span class="fu">=</span> <span class="dt">OtrMessagePayload</span> <span class="ch">'DiffieHellmanKey</span></code></pre></div>
<p>Теперь все готово для создания типа, описывающего OTR сообщение:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OtrMessage</span> payload <span class="fu">=</span> <span class="dt">OtrMessage</span>
    {<span class="ot"> protocolVersion     ::</span> <span class="fu">!</span><span class="dt">Word16</span>
    ,<span class="ot"> senderInstanceTag   ::</span> <span class="fu">!</span><span class="dt">Word32</span>
    ,<span class="ot"> receiverInstanceTag ::</span> <span class="fu">!</span><span class="dt">Word32</span>
    ,<span class="ot"> messagePayload      ::</span> <span class="fu">!</span>(<span class="dt">OtrMessagePayload</span> payload)
    }</code></pre></div>
<p>Т.к. одно из полей - это выражение на уровне типов, то мы не можем воспользоваться механизмом автоопределения реализаций классов типов. Поэтому используем расширение <code>StandaloneDeriving</code> (и <code>UndecidableInstances</code>, т.к. инстанс имеет форму отличную от <code>(C1 x, C2 x,...) =&gt; Eq x)</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> (<span class="dt">OtrMessagePayload</span> payload) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">OtrMessage</span> payload)
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">OtrMessagePayload</span> payload) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">OtrMessage</span> payload)</code></pre></div>
<p>Казалось бы уже все готово, т.к. у нас есть диаграмма: <img src="../../../../../files/posts/2016-01-06/step-3.png" /></p>
<p>Однако, все не так и хорошо, т.к. часть выражений в диаграмме у нас присутствует только на уровне типов, таким образом, если у нас они в программе статически известны, то мы можем переходить по стрелкам и получать <code>OtrMessage (..)</code> и инстансы для него. Но наша задача состоит в том, чтобы суметь осуществить этот выбор, стартуя с уровня значений, где у нас есть определенное значение типа <code>MessageType</code>.</p>
<p>Существуют различные способы связи уровня значений с уровнем типов, один из наиболее базовых вариантов - это создание <code>Proxy</code> значения. <code>Proxy</code> - это такой тип, который полиморфен по сортам. Таким образом, в случае если хочется передать тип на уровне значений, то можно воспользоваться этим типом и создать <code>Proxy :: Proxy a</code>, в этом случае при использовании данного прокси в контексте появится тип <code>a</code>. Однако этот способ не решает противоположного направления.</p>
<p>Для полноценного решения этой задачи существуют синглетоны. Синглетоном называется объект, для которого существует однозначная связь между значением и типом.</p>
<p>Рассмотрим несколько простых примеров:</p>
<ul>
<li><p>0 - Тип с 0 конструкторов, например, <code>Void</code> на уровне значений соответствует отсутствующему значению на уровне типов (или значению <code>absurd</code>, которое всегда расходится)</p></li>
<li><p>1 - Тип с одним конструктором, например, <code>()</code> имеет тривиальное соответствие уровня значений и типов.</p></li>
<li><p>2 - Тип значений с двумя конструкторами, например, <code>Bool</code>. Рассмотрим, как тут можно ввести связь: у типа Bool есть 2 значение True и False, рассмотрим, как ввести соответствие, мы введем data family</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> family <span class="dt">Sing</span> (<span class="ot">a::</span>k)<span class="ot"> ::</span> <span class="fu">*</span>
<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> <span class="ch">'True = STrue</span>
<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> <span class="ch">'False = SFalse</span></code></pre></div>
<p>В этом случае для <code>STrue</code> и <code>SFalse</code> будут однозначные соответствия со значениями на уровне типов и уровне значений (см. 1). Теперь остается сделать транзитивное соответствие <code>True &lt;-&gt; STrue &lt;-&gt; Sing (k::STrue)</code> (методы <code>fromSing</code> и <code>toSing</code>). Данный метод (более формализованный) используется в пакете <a href="https://hackage.haskell.org/package/singletons">singletons</a>, но в случае если возможности пакета не нужны, то можно сделать вариант попроще.</p></li>
<li><p>N - Тип значений с неограниченным числом конструкторов, например, <code>Positive Integer</code> – имеет однозначное соответствие с <code>Nat</code> на уровне типов, или <code>String</code> – имеет однозначное соответствие с <code>Literal</code> на уровне типов.</p></li>
</ul>
<p>В нашем случае у нас есть <span class="math inline">\(k=5\)</span> конструкторов и можно просто воспользоваться библиотекой singletons для генерации необходимых данных.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Singleton.TH</span>
<span class="fu">$</span>(genSingletons [<span class="ch">''</span><span class="dt">MessageType</span>])</code></pre></div>
<p>сгенерирует необходимый исходный код.</p>
<p>Мы получаем следующую диаграмму: <img src="../../../../../files/posts/2016-01-06/step-4.png" /></p>
<p>Теперь, когда все красивые и ненужные картинки нарисованы, то можно и написать реализации методов. Для начала определим функцию получения заголовка, данная функция будет считывать заголовок и возвращать полученный там тип сообщения <code>MessageType</code> и функцию создания Otr сообщения. Обратите внимание на <code>forall</code> в сигнатуре, он говорит, что данный тип не должен специализироваться и возвращается полиморфная функция, которая может быть специализирована по месту применения (причем с разными типами при разных применениях).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">otrHeader ::</span> <span class="dt">Get</span> (<span class="dt">MessageType</span>, forall payload <span class="fu">.</span> <span class="dt">OtrMessagePayload</span> payload <span class="ot">-&gt;</span> <span class="dt">OtrMessage</span> payload)
otrHeader <span class="fu">=</span> <span class="kw">do</span>
     v <span class="ot">&lt;-</span> short
     t <span class="ot">&lt;-</span> get
     s <span class="ot">&lt;-</span> int
     r <span class="ot">&lt;-</span> int
     return (t, <span class="dt">OtrMessage</span> v s r)</code></pre></div>
<p>Имея в наличии <code>otrHeader</code>, мы можем определить <code>Binary</code> инстанс для сообщения, в котором мы пройдем по созданным нами стрелкам в диаграмме:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Binary</span> (<span class="dt">OtrMessagePayload</span> a), <span class="dt">SingI</span> a) <span class="ot">=&gt;</span> <span class="dt">Binary</span> (<span class="dt">OtrMessage</span> a) <span class="kw">where</span>
  get <span class="fu">=</span> magic <span class="dt">Proxy</span>
    <span class="kw">where</span>
<span class="ot">      magic ::</span> <span class="dt">SingI</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> (<span class="ot">a::</span><span class="dt">MessageType</span>) <span class="ot">-&gt;</span> <span class="dt">Get</span> (<span class="dt">OtrMessage</span> a)
      magic proxy  <span class="fu">=</span> <span class="kw">do</span>
        (tag, f) <span class="ot">&lt;-</span> otrHeader
        <span class="kw">let</span> wanted <span class="fu">=</span> fromSing (singByProxy proxy)<span class="ot"> ::</span> <span class="dt">MessageType</span>
        guard (tag <span class="fu">==</span> wanted)
        f <span class="fu">&lt;$&gt;</span> get

  put m<span class="fu">@</span>(<span class="dt">OtrMessage</span> v s r p) <span class="fu">=</span> <span class="kw">do</span>
    putWord16be v
    put (fromSing <span class="fu">$</span> singByProxy m)
    putWord32be s
    putWord32be r
    put p</code></pre></div>
<p>Тут интересно это использование <code>magic</code> (можно заменить расширением <code>ScopedTypeVariables</code>), он используется только для того, чтобы ввести прокси типа, соответствующего возвращаемому. Тут т.к. мы знаем тип сообщения, которое мы хотим получить, то мы можем на уровне типов определить соответствующий ему <code>MessageType</code>, по этому типу создать Proxy значение (на уровне значений), по нему создать Singleton тип, по нему Singleton значение и сравнить с тем <code>MessageType</code>, который хранится на уровне значений, если они совпадают, то мы читаем значение правильного типа.</p>
<p>Совершив данную проверку мы можем просто применять функцию из <code>otrHeader</code> к десериализации <code>payload</code>; типы и инстансы нам уже известны.</p>
<pre><code>  Binary (OtrMessage (k::m)) --&gt; OtrMessage (k::m) ---&gt; (k::m) ----------&gt; OtrMessagePayload k        type-level
  ---------------------------------------------------------------------------------------------------------------
                                                          |                   |                       value-level
                                                       Proxy k          Get (OtrMessagePayload k)
                                                          |                   |
                                                        Sing k          Get (OtrMessage k)
                                                          |
                                                         K::m</code></pre>
<p>В случае с <code>put</code> все проще: само OTR сообщение является прокси типом для типа <code>a</code>, по нему мы можем построить синглетон и получить значение, которое и сериализуем.</p>
<p>Данный инстанс позволяет читать сообщение, тип которого мы знаем, и не позволяет конструировать сообщения, для которых необходимого <code>Binary</code> инстанса нет.</p>
<p>Для завершения остается последний шаг - уметь читать произвольное сообщение. Для этого есть два основных варианта: 1. использование экзистенциальных типов. 2. использование ADT.</p>
<p>Первый вариант нужно использовать, если там не известно точное число вариантов или множество сообщений является открытым. Поэтому мы просто построим ADT:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeOtrMessage</span>
       <span class="fu">=</span> <span class="dt">DiffieHellmanCommitTag</span> (<span class="dt">OtrMessage</span> <span class="ch">'DiffieHellmanCommit)</span>
       <span class="fu">|</span> <span class="dt">DiffieHellmanKeyTag</span>    (<span class="dt">OtrMessage</span> <span class="ch">'DiffieHellmanKey)</span>
       <span class="fu">|</span> <span class="dt">RevealSignatureTag</span>     (<span class="dt">OtrMessage</span> <span class="ch">'RevealSignature)</span>
       <span class="fu">|</span> <span class="dt">SignatureTag</span>           (<span class="dt">OtrMessage</span> <span class="ch">'Signature)</span>
       <span class="fu">|</span> <span class="dt">DataMessageTag</span>         (<span class="dt">OtrMessage</span> <span class="ch">'DataMessage)</span>
       <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p>И напишем для него инстанс <code>Binary</code>, ниже описан только метод <code>get</code>, т.к. <code>put</code> - это просто вызов метода <code>put</code> из инстанса выше для соответствующего сообщения:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  get <span class="fu">=</span> <span class="kw">do</span>
    (t, mk) <span class="ot">&lt;-</span> otrHeader
    <span class="kw">case</span> toSing t <span class="kw">of</span>
      <span class="dt">SomeSing</span> g<span class="fu">@</span><span class="dt">SDiffieHellmanCommit</span> <span class="ot">-&gt;</span> <span class="dt">DiffieHellmanCommitTag</span> <span class="fu">.</span> mk <span class="fu">&lt;$&gt;</span> magic g
      <span class="dt">SomeSing</span> g<span class="fu">@</span><span class="dt">SDiffieHellmanKey</span>    <span class="ot">-&gt;</span> <span class="dt">DiffieHellmanKeyTag</span>    <span class="fu">.</span> mk <span class="fu">&lt;$&gt;</span> magic g
      <span class="dt">SomeSing</span> _ <span class="ot">-&gt;</span> fail <span class="st">&quot;Type do not have binary instance.&quot;</span>
    <span class="kw">where</span>
<span class="ot">      magic ::</span> <span class="dt">Binary</span> (<span class="dt">OtrMessagePayload</span> k) <span class="ot">=&gt;</span> <span class="dt">Sing</span> k <span class="ot">-&gt;</span> <span class="dt">Get</span> (<span class="dt">OtrMessagePayload</span> k)
      magic _ <span class="fu">=</span> get</code></pre></div>
<p>Здесь ситуация обратная: нам не известен тип результата, зато нам известен конструктор <code>MessageType</code> в сообщении, по нему мы можем построить <code>Singleton</code> type (<code>toSing t</code>) и явно сделать матчинг по всем вариантам (ghc напишет предупреждение, если какой-то из вариантов упущен), т.к. семейство типов закрытое</p>
<pre><code>  (A::MessageType) --- Sing A                Get (OtrMessagePayload A)     value-level
------------------------|-----------------------------|---------------------------
                       (A::MT)------------------(OtrMessagePayload A)      type-level</code></pre>
<p>Вот в общем-то и все.</p>
<p>Напоследок хотелось бы обсудить несколько вопросов, вспомним нашу диаграмму.</p>
<p>Т.е. мы знаем, что если есть две стрелки, то должна существовать и их композиция, в этом случае, наверное, можно было бы избежать создания отношения <code>OtrMessagePayload</code> и сделать соотношение между типами синглетонами и <code>OtrMessagePayload</code> напрямую, однако это невозможно выразить в Haskell, т.к. результаты, полученные при применении семейств данных, нельзя применять в других семействах.</p>
<p>Также достаточно очевидно, что между конструкторами <code>MessageType</code> и десериализаторами <code>Get (OtrMessagePayload (x::MessageType))</code> существует однозначное соответствие через те же singleton типы, однако эта связь также невыразима средствами, доступными в <code>Haskell</code>.</p>
<p>Сам исходный код может быть найден на <a href="https://gist.github.com/qnikst/f8329b92277fb92026b6">gist</a>, также в истории хранятся эксперименты с другими подходами, показавшимися автору менее удобными.</p>
<p>Заключение: у автора, к сожалению, ещё недостаточный опыт работы с зависимыми типами и синглетонами, поэтому если у кого появятся заметки, как упростить решение или сделать его лучше, то это так же очень приветствуется.</p>

<div id="socialButtons">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ru">Твитнуть</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    <div class="g-plus" data-action="share" data-annotation="bubble"></div>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ruhaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    

        </div>

        <div id="searchForm">
            <script>
              (function() {
                var cx = '007697214108744450483:w49n7qbvpdy';
                var gcse = document.createElement('script');
                gcse.type = 'text/javascript';
                gcse.async = true;
                gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                    '//www.google.com/cse/cse.js?cx=' + cx;
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(gcse, s);
              })();
            </script>
            <gcse:search></gcse:search>
        </div>

        <footer class="footer">
            Сайт работает на <strong><a href="http://jaspervdj.be/hakyll/" target="_blank">Hakyll</a></strong> и живёт на <strong><a href="https://github.com/ruHaskell/ruhaskell" target="_blank">GitHub</a></strong>.
            <div class="stargaze">
                <a data-count-api="/repos/ruHaskell/ruhaskell#stargazers_count" data-count-href="/ruHaskell/ruhaskell/stargazers" data-icon="octicon-star" href="https://github.com/ruHaskell/ruhaskell" class="github-button">Star</a>

                <span style="padding-left: 20px;"></span>

                <a data-count-api="/repos/ruHaskell/ruhaskell#forks_count" data-count-href="/ruHaskell/ruhaskell/network" data-icon="octicon-git-branch" href="https://github.com/ruHaskell/ruhaskell" class="github-button">Fork</a>
            </div>

            <div class="copyright-note">
                Исходный код данного сайта, а также все опубликованные на нём материалы распространяются на условиях <a href="https://github.com/ruHaskell/ruhaskell/blob/master/LICENSE" target="_blank">свободной лицензии MIT</a>.
            </div>
        </footer>
    </div>

<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'ruhaskell'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

  </body>
</html>
